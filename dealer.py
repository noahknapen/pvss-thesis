from Cryptodome.Protocol.SecretSharing import Shamir
from Cryptodome.Protocol.SecretSharing import _Element
from Cryptodome.Random import get_random_bytes
from Cryptodome.Random.random import randint
from Cryptodome.Hash import SHA3_256
from numpy.polynomial.polynomial import Polynomial 
from numpy.polynomial.polynomial import polyval
import math

class Dealer:
    def __init__(self, n, t, q, g, parties):
        """Initialize the dealer with the necessary parameters

        Args:
            n (integer):
                The number of parties
            t (integer):
                The number of parties needed to reconstruct the secret
            q (integer):
                The prime number denoting the order of the group Z_p
            g (integer):
                The generator of the cyclic group G of prime order q
            pub_keys (tuple):
                The public keys of the parties
        """

        self.n = n
        self.t = t
        self.q = q
        self.generator = g
        self.parties = parties
        self.secret = None

    def share_secret(self, secret):
        """Given the secret to share, broadcast the encrypted shares and corresponding proof to verify these shares

        Args:
            secret (string):
                The secret to be shared
        """
        self.secret = secret
        (coefficients, f_x) = self.create_polynomial(secret)
        encrypted_share_pairs = self.generate_encrypted_shares(coefficients)
        pi_share = self.__pi_pdl(f_x, encrypted_share_pairs)
        self.__broadcast(encrypted_share_pairs, pi_share)
           
    
    #######################
    ### PRIVATE METHODS ###
    #######################

    def create_polynomial(self, secret):
        """Conform with the Shamir secret sharing scheme, create a polynomial with random coefficients in GF(2^128): p(x) = \sum_{i=0}^{k-1} c_i * x^i where c_0 is the encoded secret
        
        Args:
            secret (string):
                The secret to be encoded in the first coefficient of the polynomial

        Returns:
            A tuple consisting of the coefficients and the polynomial, respectively
        """

        int_secret = int.from_bytes(secret.encode('utf-8'), "little")
        coeffs = [_Element(int_secret)]
        coeffs += [_Element(randint(0, self.q-1)) for _ in range(self.n - 1)]
        polynomial = Polynomial(coeffs)

        return (coeffs, polynomial) 
 
    def generate_encrypted_shares(self, coefficients):
        """Given the coefficients of the polynomial generated according to the Shamir secret sharing scheme, generate the encrypted shares for each party where each share is encrypted in an ElGamal-like manner

        Args:
            coefficients (list):
                A list of the coefficients generated by `self.__create_polynomial`

        Returns:
            A list of tuples with each first element being the index of the party and the second element the encrypted share
        """
        shares = []

        for i in range(1, self.n+1):
            idx = _Element(i)
            share = _Element(0)
            for coeff in coefficients:
                share = idx * share + coeff
            
            shares.append(share)

        encrypted_share_pairs = []
        
        for i in range(self.n):
            encrypted_share_pairs.append((i, pow(_Element(self.parties[i].public_key), int(share))))

        return encrypted_share_pairs
  
    def __pi_pdl(self, polynomial, encrypted_share_pairs):
        # public keys, indices and encrypted shares
        (coeffs, r_x) = self.__create_polynomial(_Element(get_random_bytes(math.floor(math.log(self.q, 2))+1)))
        encrypted_r_x = []

        for i in range(0, self.n):
            r_i = polyval(coeffs, i+1)
            encrypted_r_x.append(pow(self.parties[i].public_key, r_i))

        args = [encrypted_share_pair[1] for encrypted_share_pair in encrypted_share_pairs] + encrypted_r_x

        d = self.__get_random_oracle_value(args)

        z_x = r_x + d*polynomial

        return (encrypted_r_x, z_x)
    
    def __get_random_oracle_value(self, *args):
        data = ""

        for arg in args:
            data += arg

        binary_data = data.encode('utf-8')
        hash_class = SHA3_256.new()
        hash_class.update(binary_data)
        binary_hash = hash_class.digest()
        return int.from_bytes(binary_hash, "little")

    def __broadcast(self, encrypted_shares, pi_share):
        for party in self.parties:
            party.receive_shares_and_dealer_proof(encrypted_shares, pi_share)