from Cryptodome.Hash import SHA3_256
from Cryptodome.Random.random import randint
from numpy.polynomial.polynomial import polyval
from Cryptodome.Util.number import inverse
from Cryptodome.PublicKey import ECC

class Party:
    def __init__(self, party_number, generator, n, t, group_order):
        """Initialization of the party
        """
        ec = ECC.generate(curve='ed25519') 
        self.private_key = ec.d
        self.public_key = ec.pointQ
        self.generator = generator
        self.number =  party_number
        self.n = n
        self.t = t
        self.q = group_order
        self.parties = None
        self.encrypted_share_pairs = None
        self.encrypted_share = None
        self.dealer_proof = None
        self.unverified_share_pairs_and_proof = []
        self.verified_share_pairs = []
    
    def receive_shares_and_dealer_proof(self, encrypted_share_pairs, pi_share):
        self.encrypted_share_pairs = encrypted_share_pairs
        self.encrypted_share = self.encrypted_share_pairs[self.number-1][1]
        self.dealer_proof = pi_share
 
    def verify_encrypted_shares(self, parties):
        """Verify the shares received from the dealer

        Arguments:
            parties (list (Party)):
                A list of Party objects representing the other parties in the network
            encrypted_share_pairs (list (tuple(integer, integer)))
                A list of tuples with each first element being the index `i` of the party, starting from 1 
                and the second element the encrypted share computed as `party_i_pub_key^f_i mod q` with `f_i` being the evaluation in `i` of the polynomial `f` to which the coefficients belong
            pi_share (tuple (list (integer), Polynomial)):
                A tuple with the first element being a list of the encrypted `r(i)` evaluations and the second element the polynomial `z(x)` as described in `dealer.py (Dealer().pi_pdl())`

        Returns:
            result (boolean):
                True if all shares are successfully verified. False otherwise
        """
        self.parties = parties

        d = self.dealer_proof[0]
        z_x = self.dealer_proof[1]

        if z_x.degree() != self.t:
            return False

        z_x_coeffs = z_x.coef
        encrypted_r_x = []

        for i in range(0, self.n):
            z_i = polyval(i+1, z_x_coeffs)
            encrypted_z_i = pow(self.parties[i].public_key, z_i, self.q)
            inv_encrypted_share = inverse(self.encrypted_share_pairs[i][1], self.q)
            yd = pow(inv_encrypted_share, d, self.q)
            encrypted_r_x.append((encrypted_z_i * yd) % self.q)
            
        args = [encrypted_share_pair[1] for encrypted_share_pair in self.encrypted_share_pairs] + encrypted_r_x
        d_test = self.get_random_oracle_value(args)

        return d == d_test

    def generate_decrypted_share(self):
        """Note that the decrypted share is not the share `f(i)` generated by the dealer, but `generator^f(i)`.

        Returns:
            result (integer):
                The decrypted share `generator^f(i)` of this party
        """
        inv_priv_key = inverse(self.private_key, self.q)
        share = pow(self.encrypted_share, inv_priv_key, self.q)
        return share
    
    def publish_decrypted_share_and_proof(self): #! This method is not necessary if shallow copies of the Party object are given to the other parties and dealer
        """Broadcast the decrypted share and a NIZK proof
        Note that the decrypted share is not the share `f(i)` generated by the dealer, but `generator^f(i)`.
        The proof serves as a validation that the decrypted share is a correct decryption of the corresponding encrypted share
        """
        share = self.generate_decrypted_share()
        share_proof = self.nizk_proof_for_dleq(share)
        self.broadcast((self.number, share), share_proof)
        
    def receive_decrypted_share_and_proof(self, decrypted_share_pair, share_proof):
        """Receive a decrypted share and corresponding NIZK proof

        Arguments:
            decrypted_share_pair (tuple (integer, integer)):
                A tuple with the first element being the index of the party sending its decrypted share and the second element the decrypted share `generator^f(i)`
            share_proof (tuple (integer, integer)):
                A tuple with the first element being a random oracle value based on the public key, encrypted share, `generator^r` and `decrypted_share^r` with `r` being a random element in Z_q
                and the second element `z = (r + d*private_key) mod q`
        """
        self.unverified_share_pairs_and_proof.append((decrypted_share_pair, share_proof))

    def verify_decrypted_shares(self):
        """Verify the decrypted share using the NIZK proof scheme for the DLEQ relation 
        If the decrypted share is valid, it is stored. Otherwise, it is ignored
        """
        for (decrypted_share_pair, share_proof) in self.unverified_share_pairs_and_proof:
            i = decrypted_share_pair[0] - 1
            h = decrypted_share_pair[1]
            a = self.parties[i].public_key
            b = self.encrypted_share_pairs[i][1]
            d = share_proof[0]
            z = share_proof[1]
            reconstructed_g_r = (pow(self.generator, z, self.q) * pow(inverse(a, self.q), d, self.q)) % self.q
            reconstructed_dec_share_r = (pow(h, z, self.q) * pow(inverse(b, self.q), d, self.q)) % self.q

            d_test = self.get_random_oracle_value([a, b, reconstructed_g_r, reconstructed_dec_share_r])

            if d == d_test:
               self.verified_share_pairs.append(decrypted_share_pair) 


    def reconstruct_secret(self):
        """Reconstruct the secret `f(0)` in the form of `generator^f(0)`

        Returns:
            result (integer):
                Returns `generator^f(0)`
        """
        # Assume self.unverified_share_pairs_and_proof is an ordered list of tuples (i, share)
        exponent = 0

        for i in range(0, self.t+1):
            decrypted_share = self.unverified_share_pairs_and_proof[i][1]
            lagrange_coeff = self.compute_lagrange_coefficient(i)
            exponent += lagrange_coeff * decrypted_share

        return pow(self.generator, exponent) #! Verify this because I am not sure this is right

    def compute_lagrange_coefficient(self, i):
        """Compute the Lagrange coefficient for the given index

        Arguments:
            i (integer):
                The index for which to calculate the Lagrange coefficient
        
        Returns:
            result (integer):
                The Lagrange coefficient `lambda_i = mul_j!=i_(j/(j-i))`
        """
        numerator = 1
        denominator = 1

        for j in range(0, self.t+1):
            if j != i:
                numerator *= j
                denominator *= j - i

        return numerator / denominator #? Is division allowed here or is it mod q and thus using multiplication with the inverse?
        
    def get_random_oracle_value(self, args):
        """Given a list of arguments, return a random oracle value based on this list

        Arguments:
            args (list (any)):
                The list holding all arguments that should be given to the random oracle

        Returns:
            result (integer):
                The random oracle value calculated based on the provided arguments
        """
        data = ""

        for arg in args:
            data += str(arg)

        binary_data = data.encode('utf-8')
        hash_class = SHA3_256.new()
        hash_class.update(binary_data)
        binary_hash = hash_class.digest()
        return int.from_bytes(binary_hash, "little")
        
    def nizk_proof_for_dleq(self, decrypted_share):
        """Given a decrypted share, generate a proof based on the NIZK proof scheme for the DLEQ relation that this is indeed the correct decryption of the corresponding encrypted share

        Arguments: 
            decrypted_share (integer):
                the decrypted share `generator^f(i)`
        Returns:
            result (tuple (integer, integer)):
                A tuple with the first element being a random oracle value based on the public key, encrypted share, `generator^r` and `decrypted_share^r` with `r` being a random element in Z_q
                and the second element `z = (r + d*private_key) mod q`
        """
        r = randint(0, self.q-1) 
        d = self.get_random_oracle_value([self.public_key, self.encrypted_share, pow(self.generator, r, self.q), pow(decrypted_share, r, self.q)])
        z = (r + d*self.private_key) % self.q
        
        return (d, z) 

    def broadcast(self, decrypted_share, share_proof):
        """Given the decrypted share and the NIZK proof of knowledge, broadcast this to all parties on the network

        Arguments:
            decrypted_shares (list (tuple(integer, integer)))
                A list of tuples with each first element being the index `i` of the party, starting from 1 
                and the second element the decrypted share `generator^f(i)`
            share_proof (tuple (integer, integer)):
                A tuple with the first element being a random oracle value based on the public key, encrypted share, `generator^r` and `decrypted_share^r` with `r` being a random element in Z_q
                and the second element `z = (r + d*private_key) mod q`
        """
        for party in self.parties:
            party.receive_decrypted_share_and_proof(decrypted_share, share_proof)
    