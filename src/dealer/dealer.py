from Cryptodome.Protocol.SecretSharing import Shamir
from Cryptodome.Protocol.SecretSharing import _Element
from Cryptodome.Random import get_random_bytes
from numpy.polynomial import Polynomial

class Dealer:
    def __init__(self, n, t, q, g, pub_keys):
        """Initialize the dealer with the necessary parameters

        Args:
            n (integer):
                The number of parties
            t (integer):
                The number of parties needed to reconstruct the secret
            q (integer):
                The prime number denoting the order of the group Z_p
            g (integer):
                The generator of the cyclic group G of prime order q
            pub_keys (tuple):
                The public keys of the parties
        """

        self.n = n
        self.t = t
        self.q = q
        self.generator = g
        self.pub_keys = pub_keys

    def share_secret(self, secret):
        """Given the secret to share, broadcast the encrypted shares and corresponding proof to verify these shares

        Args:
            secret (string):
                The secret to be shared
        """
        (coefficients, polynomial) = self.__create_polynomial(secret)
        encrypted_shares = self.__generate_encrypted_shares(coefficients)
        pi_share = self.__pi_pdl(polynomial, self.pub_keys, encrypted_shares)
        self.__broadcast(encrypted_shares, pi_share)
           
    
    #######################
    ### PRIVATE METHODS ###
    #######################

    def __create_polynomial(self, secret):
        """Conform with the Shamir secret sharing scheme, create a polynomial with random coefficients in GF(2^128): p(x) = \sum_{i=0}^{k-1} c_i * x^i where c_0 is the encoded secret
        
        Args:
            secret (string):
                The secret to be encoded in the first coefficient of the polynomial

        Returns:
            A tuple consisting of the coefficients and the polynomial, respectively
        """

        coeffs = [_Element(get_random_bytes(16)) for i in range(self.t - 1)] #? Should self.q be worked into this instead of just 16 bytes?
        coeffs.append(_Element(secret))

        polynomial = Polynomial(coeffs)

        return (coeffs, polynomial) 
 
    def __generate_encrypted_shares(self, coefficients):
        """Given the coefficients of the polynomial generated according to the Shamir secret sharing scheme, generate the encrypted shares for each party where each share is encrypted in an ElGamal-like manner

        Args:
            coefficients (list):
                A list of the coefficients generated by `self.__create_polynomial`

        Returns:
            A list of tuples with each first element being the index of the party and the second element the encrypted share
        """
        shares = self.__generate_shares(coefficients)
        encrypted_shares = self.__encrypt_shares(shares)
        return encrypted_shares
    
    def __generate_shares(self, coefficients):
        """Given the coefficients of the polynomial generated according to the Shamir secret sharing scheme, generate the shares for each party

        Args:
            coefficients (list):
                A list of the coefficients generated by `self.__create_polynomial`

        Returns:
            A list of tuples with each first element being the index of the party and the second element the share
        """

        def make_share(user, coeffs):
            idx = _Element(user)
            share = _Element(0)
            for coeff in coeffs:
                share = idx * share + coeff

            return share.encode()

        return [(i, make_share(i, coefficients)) for i in range(1, self.n+1)]
        
    def __encrypt_shares(self, shares):
        """Encrypt the shares generated by `self.__generate_shares`

        Args:
            shares (list):
                A list of tuples with each first element being the index of the party and the second element the share
        
        Returns:
            A list of tuples with each first element being the index of the party and the second element the encrypted share
        """
        encrypted_shares = []
        
        for i in range(len(shares)):
            encrypted_shares.append((shares[i][0], self.__encrypt_share(shares[i][1], self.pub_keys[i])))

        return encrypted_shares

    def __encrypt_share(self, share, pub_key):
        """Encrypt the given share with the given public key in an ElGamal-like manner

        Args:
            share (bytes):
                The share of a party
            pub_key (bytes):
                The corresponding public key of that party
        
        Returns:
            An integer representing the share encrypted with the public key
        """
        pub_key_int = int.from_bytes(pub_key, "little")
        share_int = int.from_bytes(share, "little")
        return pow(pub_key_int, share_int)

    def __pi_pdl(self, encrypted_shares): 
        pass

    def __broadcast(self, encrypted_shares, pi_share):
        pass